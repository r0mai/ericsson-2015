// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Elements.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Elements.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace protocol {

namespace {

const ::google::protobuf::Descriptor* FluxCapatitor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FluxCapatitor_reflection_ = NULL;
const ::google::protobuf::Descriptor* FluxCapatitorInformations_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FluxCapatitorInformations_reflection_ = NULL;
const ::google::protobuf::Descriptor* Doc_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Doc_reflection_ = NULL;
const ::google::protobuf::Descriptor* Enemy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Enemy_reflection_ = NULL;
const ::google::protobuf::Descriptor* Chest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Chest_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeLorean_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeLorean_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Capability_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_Elements_2eproto() {
  protobuf_AddDesc_Elements_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Elements.proto");
  GOOGLE_CHECK(file != NULL);
  FluxCapatitor_descriptor_ = file->message_type(0);
  static const int FluxCapatitor_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FluxCapatitor, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FluxCapatitor, time_to_activated_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FluxCapatitor, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FluxCapatitor, timetravel_length_),
  };
  FluxCapatitor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FluxCapatitor_descriptor_,
      FluxCapatitor::default_instance_,
      FluxCapatitor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FluxCapatitor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FluxCapatitor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FluxCapatitor));
  FluxCapatitorInformations_descriptor_ = file->message_type(1);
  static const int FluxCapatitorInformations_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FluxCapatitorInformations, next_done_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FluxCapatitorInformations, making_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FluxCapatitorInformations, max_flux_capatitors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FluxCapatitorInformations, next_flux_capatitor_),
  };
  FluxCapatitorInformations_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FluxCapatitorInformations_descriptor_,
      FluxCapatitorInformations::default_instance_,
      FluxCapatitorInformations_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FluxCapatitorInformations, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FluxCapatitorInformations, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FluxCapatitorInformations));
  Doc_descriptor_ = file->message_type(2);
  static const int Doc_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Doc, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Doc, survive_timetravels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Doc, flux_capatitors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Doc, informations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Doc, capabilities_),
  };
  Doc_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Doc_descriptor_,
      Doc::default_instance_,
      Doc_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Doc, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Doc, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Doc));
  Enemy_descriptor_ = file->message_type(3);
  static const int Enemy_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Enemy, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Enemy, survive_timetravels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Enemy, intelligence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Enemy, radius_),
  };
  Enemy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Enemy_descriptor_,
      Enemy::default_instance_,
      Enemy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Enemy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Enemy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Enemy));
  Chest_descriptor_ = file->message_type(4);
  static const int Chest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chest, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chest, survive_timetravels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chest, capability_),
  };
  Chest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Chest_descriptor_,
      Chest::default_instance_,
      Chest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Chest));
  DeLorean_descriptor_ = file->message_type(5);
  static const int DeLorean_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeLorean, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeLorean, survive_timetravels_),
  };
  DeLorean_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DeLorean_descriptor_,
      DeLorean::default_instance_,
      DeLorean_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeLorean, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeLorean, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DeLorean));
  Capability_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Elements_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FluxCapatitor_descriptor_, &FluxCapatitor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FluxCapatitorInformations_descriptor_, &FluxCapatitorInformations::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Doc_descriptor_, &Doc::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Enemy_descriptor_, &Enemy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Chest_descriptor_, &Chest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DeLorean_descriptor_, &DeLorean::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Elements_2eproto() {
  delete FluxCapatitor::default_instance_;
  delete FluxCapatitor_reflection_;
  delete FluxCapatitorInformations::default_instance_;
  delete FluxCapatitorInformations_reflection_;
  delete Doc::default_instance_;
  delete Doc_reflection_;
  delete Enemy::default_instance_;
  delete Enemy_reflection_;
  delete Chest::default_instance_;
  delete Chest_reflection_;
  delete DeLorean::default_instance_;
  delete DeLorean_reflection_;
}

void protobuf_AddDesc_Elements_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016Elements.proto\022\010protocol\"a\n\rFluxCapati"
    "tor\022\n\n\002id\030\001 \002(\r\022\031\n\021time_to_activated\030\002 \002"
    "(\r\022\016\n\006radius\030\003 \002(\r\022\031\n\021timetravel_length\030"
    "\004 \001(\r\"\233\001\n\031FluxCapatitorInformations\022\026\n\016n"
    "ext_done_time\030\001 \001(\r\022\023\n\013making_time\030\002 \002(\r"
    "\022\033\n\023max_flux_capatitors\030\003 \002(\r\0224\n\023next_fl"
    "ux_capatitor\030\004 \002(\0132\027.protocol.FluxCapati"
    "tor\"\307\001\n\003Doc\022\n\n\002id\030\001 \002(\r\022\033\n\023survive_timet"
    "ravels\030\002 \002(\r\0220\n\017flux_capatitors\030\003 \003(\0132\027."
    "protocol.FluxCapatitor\0229\n\014informations\030\004"
    " \002(\0132#.protocol.FluxCapatitorInformation"
    "s\022*\n\014capabilities\030\005 \003(\0162\024.protocol.Capab"
    "ility\"V\n\005Enemy\022\n\n\002id\030\001 \002(\r\022\033\n\023survive_ti"
    "metravels\030\002 \002(\r\022\024\n\014intelligence\030\003 \002(\r\022\016\n"
    "\006radius\030\004 \002(\r\"Z\n\005Chest\022\n\n\002id\030\001 \002(\r\022\033\n\023su"
    "rvive_timetravels\030\002 \002(\r\022(\n\ncapability\030\003 "
    "\001(\0162\024.protocol.Capability\"3\n\010DeLorean\022\n\n"
    "\002id\030\001 \002(\r\022\033\n\023survive_timetravels\030\002 \002(\r*\216"
    "\002\n\nCapability\022\034\n\030INCREASEMAXFLUXCAPATITO"
    "R\020\001\022\037\n\033INCREASEFLUXCAPATITORRADIUS\020\002\022\037\n\033"
    "DECREASEFLUXCAPATITORRADIUS\020\003\022\035\n\031INCREAS"
    "EFLUXCAPATITORTIME\020\004\022\035\n\031DECREASEFLUXCAPA"
    "TITORTIME\020\005\022\037\n\033DECREASEFLUXCAPATITORMAKI"
    "NG\020\006\022\022\n\016INCREASEENERGY\020\007\022\025\n\021KICKFLUXCAPA"
    "TITOR\020\010\022\026\n\022THROWFLUXCAPATITOR\020\t", 991);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Elements.proto", &protobuf_RegisterTypes);
  FluxCapatitor::default_instance_ = new FluxCapatitor();
  FluxCapatitorInformations::default_instance_ = new FluxCapatitorInformations();
  Doc::default_instance_ = new Doc();
  Enemy::default_instance_ = new Enemy();
  Chest::default_instance_ = new Chest();
  DeLorean::default_instance_ = new DeLorean();
  FluxCapatitor::default_instance_->InitAsDefaultInstance();
  FluxCapatitorInformations::default_instance_->InitAsDefaultInstance();
  Doc::default_instance_->InitAsDefaultInstance();
  Enemy::default_instance_->InitAsDefaultInstance();
  Chest::default_instance_->InitAsDefaultInstance();
  DeLorean::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Elements_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Elements_2eproto {
  StaticDescriptorInitializer_Elements_2eproto() {
    protobuf_AddDesc_Elements_2eproto();
  }
} static_descriptor_initializer_Elements_2eproto_;
const ::google::protobuf::EnumDescriptor* Capability_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Capability_descriptor_;
}
bool Capability_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int FluxCapatitor::kIdFieldNumber;
const int FluxCapatitor::kTimeToActivatedFieldNumber;
const int FluxCapatitor::kRadiusFieldNumber;
const int FluxCapatitor::kTimetravelLengthFieldNumber;
#endif  // !_MSC_VER

FluxCapatitor::FluxCapatitor()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.FluxCapatitor)
}

void FluxCapatitor::InitAsDefaultInstance() {
}

FluxCapatitor::FluxCapatitor(const FluxCapatitor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protocol.FluxCapatitor)
}

void FluxCapatitor::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  time_to_activated_ = 0u;
  radius_ = 0u;
  timetravel_length_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FluxCapatitor::~FluxCapatitor() {
  // @@protoc_insertion_point(destructor:protocol.FluxCapatitor)
  SharedDtor();
}

void FluxCapatitor::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FluxCapatitor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FluxCapatitor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FluxCapatitor_descriptor_;
}

const FluxCapatitor& FluxCapatitor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Elements_2eproto();
  return *default_instance_;
}

FluxCapatitor* FluxCapatitor::default_instance_ = NULL;

FluxCapatitor* FluxCapatitor::New() const {
  return new FluxCapatitor;
}

void FluxCapatitor::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FluxCapatitor*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, timetravel_length_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FluxCapatitor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.FluxCapatitor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_to_activated;
        break;
      }

      // required uint32 time_to_activated = 2;
      case 2: {
        if (tag == 16) {
         parse_time_to_activated:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_to_activated_)));
          set_has_time_to_activated();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_radius;
        break;
      }

      // required uint32 radius = 3;
      case 3: {
        if (tag == 24) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_timetravel_length;
        break;
      }

      // optional uint32 timetravel_length = 4;
      case 4: {
        if (tag == 32) {
         parse_timetravel_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timetravel_length_)));
          set_has_timetravel_length();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.FluxCapatitor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.FluxCapatitor)
  return false;
#undef DO_
}

void FluxCapatitor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.FluxCapatitor)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 time_to_activated = 2;
  if (has_time_to_activated()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_to_activated(), output);
  }

  // required uint32 radius = 3;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->radius(), output);
  }

  // optional uint32 timetravel_length = 4;
  if (has_timetravel_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->timetravel_length(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.FluxCapatitor)
}

::google::protobuf::uint8* FluxCapatitor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.FluxCapatitor)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required uint32 time_to_activated = 2;
  if (has_time_to_activated()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_to_activated(), target);
  }

  // required uint32 radius = 3;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->radius(), target);
  }

  // optional uint32 timetravel_length = 4;
  if (has_timetravel_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->timetravel_length(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.FluxCapatitor)
  return target;
}

int FluxCapatitor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 time_to_activated = 2;
    if (has_time_to_activated()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_to_activated());
    }

    // required uint32 radius = 3;
    if (has_radius()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->radius());
    }

    // optional uint32 timetravel_length = 4;
    if (has_timetravel_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timetravel_length());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FluxCapatitor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FluxCapatitor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FluxCapatitor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FluxCapatitor::MergeFrom(const FluxCapatitor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_time_to_activated()) {
      set_time_to_activated(from.time_to_activated());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
    if (from.has_timetravel_length()) {
      set_timetravel_length(from.timetravel_length());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FluxCapatitor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FluxCapatitor::CopyFrom(const FluxCapatitor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FluxCapatitor::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void FluxCapatitor::Swap(FluxCapatitor* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(time_to_activated_, other->time_to_activated_);
    std::swap(radius_, other->radius_);
    std::swap(timetravel_length_, other->timetravel_length_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FluxCapatitor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FluxCapatitor_descriptor_;
  metadata.reflection = FluxCapatitor_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FluxCapatitorInformations::kNextDoneTimeFieldNumber;
const int FluxCapatitorInformations::kMakingTimeFieldNumber;
const int FluxCapatitorInformations::kMaxFluxCapatitorsFieldNumber;
const int FluxCapatitorInformations::kNextFluxCapatitorFieldNumber;
#endif  // !_MSC_VER

FluxCapatitorInformations::FluxCapatitorInformations()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.FluxCapatitorInformations)
}

void FluxCapatitorInformations::InitAsDefaultInstance() {
  next_flux_capatitor_ = const_cast< ::protocol::FluxCapatitor*>(&::protocol::FluxCapatitor::default_instance());
}

FluxCapatitorInformations::FluxCapatitorInformations(const FluxCapatitorInformations& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protocol.FluxCapatitorInformations)
}

void FluxCapatitorInformations::SharedCtor() {
  _cached_size_ = 0;
  next_done_time_ = 0u;
  making_time_ = 0u;
  max_flux_capatitors_ = 0u;
  next_flux_capatitor_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FluxCapatitorInformations::~FluxCapatitorInformations() {
  // @@protoc_insertion_point(destructor:protocol.FluxCapatitorInformations)
  SharedDtor();
}

void FluxCapatitorInformations::SharedDtor() {
  if (this != default_instance_) {
    delete next_flux_capatitor_;
  }
}

void FluxCapatitorInformations::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FluxCapatitorInformations::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FluxCapatitorInformations_descriptor_;
}

const FluxCapatitorInformations& FluxCapatitorInformations::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Elements_2eproto();
  return *default_instance_;
}

FluxCapatitorInformations* FluxCapatitorInformations::default_instance_ = NULL;

FluxCapatitorInformations* FluxCapatitorInformations::New() const {
  return new FluxCapatitorInformations;
}

void FluxCapatitorInformations::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FluxCapatitorInformations*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(next_done_time_, making_time_);
    max_flux_capatitors_ = 0u;
    if (has_next_flux_capatitor()) {
      if (next_flux_capatitor_ != NULL) next_flux_capatitor_->::protocol::FluxCapatitor::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FluxCapatitorInformations::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.FluxCapatitorInformations)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 next_done_time = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &next_done_time_)));
          set_has_next_done_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_making_time;
        break;
      }

      // required uint32 making_time = 2;
      case 2: {
        if (tag == 16) {
         parse_making_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &making_time_)));
          set_has_making_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_max_flux_capatitors;
        break;
      }

      // required uint32 max_flux_capatitors = 3;
      case 3: {
        if (tag == 24) {
         parse_max_flux_capatitors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_flux_capatitors_)));
          set_has_max_flux_capatitors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_next_flux_capatitor;
        break;
      }

      // required .protocol.FluxCapatitor next_flux_capatitor = 4;
      case 4: {
        if (tag == 34) {
         parse_next_flux_capatitor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_next_flux_capatitor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.FluxCapatitorInformations)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.FluxCapatitorInformations)
  return false;
#undef DO_
}

void FluxCapatitorInformations::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.FluxCapatitorInformations)
  // optional uint32 next_done_time = 1;
  if (has_next_done_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->next_done_time(), output);
  }

  // required uint32 making_time = 2;
  if (has_making_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->making_time(), output);
  }

  // required uint32 max_flux_capatitors = 3;
  if (has_max_flux_capatitors()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->max_flux_capatitors(), output);
  }

  // required .protocol.FluxCapatitor next_flux_capatitor = 4;
  if (has_next_flux_capatitor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->next_flux_capatitor(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.FluxCapatitorInformations)
}

::google::protobuf::uint8* FluxCapatitorInformations::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.FluxCapatitorInformations)
  // optional uint32 next_done_time = 1;
  if (has_next_done_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->next_done_time(), target);
  }

  // required uint32 making_time = 2;
  if (has_making_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->making_time(), target);
  }

  // required uint32 max_flux_capatitors = 3;
  if (has_max_flux_capatitors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->max_flux_capatitors(), target);
  }

  // required .protocol.FluxCapatitor next_flux_capatitor = 4;
  if (has_next_flux_capatitor()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->next_flux_capatitor(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.FluxCapatitorInformations)
  return target;
}

int FluxCapatitorInformations::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 next_done_time = 1;
    if (has_next_done_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->next_done_time());
    }

    // required uint32 making_time = 2;
    if (has_making_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->making_time());
    }

    // required uint32 max_flux_capatitors = 3;
    if (has_max_flux_capatitors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_flux_capatitors());
    }

    // required .protocol.FluxCapatitor next_flux_capatitor = 4;
    if (has_next_flux_capatitor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->next_flux_capatitor());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FluxCapatitorInformations::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FluxCapatitorInformations* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FluxCapatitorInformations*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FluxCapatitorInformations::MergeFrom(const FluxCapatitorInformations& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_next_done_time()) {
      set_next_done_time(from.next_done_time());
    }
    if (from.has_making_time()) {
      set_making_time(from.making_time());
    }
    if (from.has_max_flux_capatitors()) {
      set_max_flux_capatitors(from.max_flux_capatitors());
    }
    if (from.has_next_flux_capatitor()) {
      mutable_next_flux_capatitor()->::protocol::FluxCapatitor::MergeFrom(from.next_flux_capatitor());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FluxCapatitorInformations::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FluxCapatitorInformations::CopyFrom(const FluxCapatitorInformations& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FluxCapatitorInformations::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;

  if (has_next_flux_capatitor()) {
    if (!this->next_flux_capatitor().IsInitialized()) return false;
  }
  return true;
}

void FluxCapatitorInformations::Swap(FluxCapatitorInformations* other) {
  if (other != this) {
    std::swap(next_done_time_, other->next_done_time_);
    std::swap(making_time_, other->making_time_);
    std::swap(max_flux_capatitors_, other->max_flux_capatitors_);
    std::swap(next_flux_capatitor_, other->next_flux_capatitor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FluxCapatitorInformations::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FluxCapatitorInformations_descriptor_;
  metadata.reflection = FluxCapatitorInformations_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Doc::kIdFieldNumber;
const int Doc::kSurviveTimetravelsFieldNumber;
const int Doc::kFluxCapatitorsFieldNumber;
const int Doc::kInformationsFieldNumber;
const int Doc::kCapabilitiesFieldNumber;
#endif  // !_MSC_VER

Doc::Doc()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.Doc)
}

void Doc::InitAsDefaultInstance() {
  informations_ = const_cast< ::protocol::FluxCapatitorInformations*>(&::protocol::FluxCapatitorInformations::default_instance());
}

Doc::Doc(const Doc& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protocol.Doc)
}

void Doc::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  survive_timetravels_ = 0u;
  informations_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Doc::~Doc() {
  // @@protoc_insertion_point(destructor:protocol.Doc)
  SharedDtor();
}

void Doc::SharedDtor() {
  if (this != default_instance_) {
    delete informations_;
  }
}

void Doc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Doc::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Doc_descriptor_;
}

const Doc& Doc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Elements_2eproto();
  return *default_instance_;
}

Doc* Doc::default_instance_ = NULL;

Doc* Doc::New() const {
  return new Doc;
}

void Doc::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Doc*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 11) {
    ZR_(id_, survive_timetravels_);
    if (has_informations()) {
      if (informations_ != NULL) informations_->::protocol::FluxCapatitorInformations::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  flux_capatitors_.Clear();
  capabilities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Doc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.Doc)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_survive_timetravels;
        break;
      }

      // required uint32 survive_timetravels = 2;
      case 2: {
        if (tag == 16) {
         parse_survive_timetravels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &survive_timetravels_)));
          set_has_survive_timetravels();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_flux_capatitors;
        break;
      }

      // repeated .protocol.FluxCapatitor flux_capatitors = 3;
      case 3: {
        if (tag == 26) {
         parse_flux_capatitors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_flux_capatitors()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_flux_capatitors;
        if (input->ExpectTag(34)) goto parse_informations;
        break;
      }

      // required .protocol.FluxCapatitorInformations informations = 4;
      case 4: {
        if (tag == 34) {
         parse_informations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_informations()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_capabilities;
        break;
      }

      // repeated .protocol.Capability capabilities = 5;
      case 5: {
        if (tag == 40) {
         parse_capabilities:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::Capability_IsValid(value)) {
            add_capabilities(static_cast< ::protocol::Capability >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else if (tag == 42) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(
                 input,
                 &::protocol::Capability_IsValid,
                 this->mutable_capabilities())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_capabilities;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.Doc)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.Doc)
  return false;
#undef DO_
}

void Doc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.Doc)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 survive_timetravels = 2;
  if (has_survive_timetravels()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->survive_timetravels(), output);
  }

  // repeated .protocol.FluxCapatitor flux_capatitors = 3;
  for (int i = 0; i < this->flux_capatitors_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->flux_capatitors(i), output);
  }

  // required .protocol.FluxCapatitorInformations informations = 4;
  if (has_informations()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->informations(), output);
  }

  // repeated .protocol.Capability capabilities = 5;
  for (int i = 0; i < this->capabilities_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->capabilities(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.Doc)
}

::google::protobuf::uint8* Doc::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.Doc)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required uint32 survive_timetravels = 2;
  if (has_survive_timetravels()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->survive_timetravels(), target);
  }

  // repeated .protocol.FluxCapatitor flux_capatitors = 3;
  for (int i = 0; i < this->flux_capatitors_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->flux_capatitors(i), target);
  }

  // required .protocol.FluxCapatitorInformations informations = 4;
  if (has_informations()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->informations(), target);
  }

  // repeated .protocol.Capability capabilities = 5;
  for (int i = 0; i < this->capabilities_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->capabilities(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.Doc)
  return target;
}

int Doc::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 survive_timetravels = 2;
    if (has_survive_timetravels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->survive_timetravels());
    }

    // required .protocol.FluxCapatitorInformations informations = 4;
    if (has_informations()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->informations());
    }

  }
  // repeated .protocol.FluxCapatitor flux_capatitors = 3;
  total_size += 1 * this->flux_capatitors_size();
  for (int i = 0; i < this->flux_capatitors_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->flux_capatitors(i));
  }

  // repeated .protocol.Capability capabilities = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->capabilities_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->capabilities(i));
    }
    total_size += 1 * this->capabilities_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Doc::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Doc* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Doc*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Doc::MergeFrom(const Doc& from) {
  GOOGLE_CHECK_NE(&from, this);
  flux_capatitors_.MergeFrom(from.flux_capatitors_);
  capabilities_.MergeFrom(from.capabilities_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_survive_timetravels()) {
      set_survive_timetravels(from.survive_timetravels());
    }
    if (from.has_informations()) {
      mutable_informations()->::protocol::FluxCapatitorInformations::MergeFrom(from.informations());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Doc::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Doc::CopyFrom(const Doc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Doc::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->flux_capatitors())) return false;
  if (has_informations()) {
    if (!this->informations().IsInitialized()) return false;
  }
  return true;
}

void Doc::Swap(Doc* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(survive_timetravels_, other->survive_timetravels_);
    flux_capatitors_.Swap(&other->flux_capatitors_);
    std::swap(informations_, other->informations_);
    capabilities_.Swap(&other->capabilities_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Doc::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Doc_descriptor_;
  metadata.reflection = Doc_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Enemy::kIdFieldNumber;
const int Enemy::kSurviveTimetravelsFieldNumber;
const int Enemy::kIntelligenceFieldNumber;
const int Enemy::kRadiusFieldNumber;
#endif  // !_MSC_VER

Enemy::Enemy()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.Enemy)
}

void Enemy::InitAsDefaultInstance() {
}

Enemy::Enemy(const Enemy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protocol.Enemy)
}

void Enemy::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  survive_timetravels_ = 0u;
  intelligence_ = 0u;
  radius_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Enemy::~Enemy() {
  // @@protoc_insertion_point(destructor:protocol.Enemy)
  SharedDtor();
}

void Enemy::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Enemy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Enemy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Enemy_descriptor_;
}

const Enemy& Enemy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Elements_2eproto();
  return *default_instance_;
}

Enemy* Enemy::default_instance_ = NULL;

Enemy* Enemy::New() const {
  return new Enemy;
}

void Enemy::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Enemy*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, radius_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Enemy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.Enemy)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_survive_timetravels;
        break;
      }

      // required uint32 survive_timetravels = 2;
      case 2: {
        if (tag == 16) {
         parse_survive_timetravels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &survive_timetravels_)));
          set_has_survive_timetravels();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_intelligence;
        break;
      }

      // required uint32 intelligence = 3;
      case 3: {
        if (tag == 24) {
         parse_intelligence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &intelligence_)));
          set_has_intelligence();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_radius;
        break;
      }

      // required uint32 radius = 4;
      case 4: {
        if (tag == 32) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.Enemy)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.Enemy)
  return false;
#undef DO_
}

void Enemy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.Enemy)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 survive_timetravels = 2;
  if (has_survive_timetravels()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->survive_timetravels(), output);
  }

  // required uint32 intelligence = 3;
  if (has_intelligence()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->intelligence(), output);
  }

  // required uint32 radius = 4;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->radius(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.Enemy)
}

::google::protobuf::uint8* Enemy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.Enemy)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required uint32 survive_timetravels = 2;
  if (has_survive_timetravels()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->survive_timetravels(), target);
  }

  // required uint32 intelligence = 3;
  if (has_intelligence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->intelligence(), target);
  }

  // required uint32 radius = 4;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->radius(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.Enemy)
  return target;
}

int Enemy::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 survive_timetravels = 2;
    if (has_survive_timetravels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->survive_timetravels());
    }

    // required uint32 intelligence = 3;
    if (has_intelligence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->intelligence());
    }

    // required uint32 radius = 4;
    if (has_radius()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->radius());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Enemy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Enemy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Enemy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Enemy::MergeFrom(const Enemy& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_survive_timetravels()) {
      set_survive_timetravels(from.survive_timetravels());
    }
    if (from.has_intelligence()) {
      set_intelligence(from.intelligence());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Enemy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Enemy::CopyFrom(const Enemy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Enemy::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Enemy::Swap(Enemy* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(survive_timetravels_, other->survive_timetravels_);
    std::swap(intelligence_, other->intelligence_);
    std::swap(radius_, other->radius_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Enemy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Enemy_descriptor_;
  metadata.reflection = Enemy_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Chest::kIdFieldNumber;
const int Chest::kSurviveTimetravelsFieldNumber;
const int Chest::kCapabilityFieldNumber;
#endif  // !_MSC_VER

Chest::Chest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.Chest)
}

void Chest::InitAsDefaultInstance() {
}

Chest::Chest(const Chest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protocol.Chest)
}

void Chest::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  survive_timetravels_ = 0u;
  capability_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Chest::~Chest() {
  // @@protoc_insertion_point(destructor:protocol.Chest)
  SharedDtor();
}

void Chest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Chest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Chest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Chest_descriptor_;
}

const Chest& Chest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Elements_2eproto();
  return *default_instance_;
}

Chest* Chest::default_instance_ = NULL;

Chest* Chest::New() const {
  return new Chest;
}

void Chest::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Chest*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(id_, survive_timetravels_);
    capability_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Chest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.Chest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_survive_timetravels;
        break;
      }

      // required uint32 survive_timetravels = 2;
      case 2: {
        if (tag == 16) {
         parse_survive_timetravels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &survive_timetravels_)));
          set_has_survive_timetravels();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_capability;
        break;
      }

      // optional .protocol.Capability capability = 3;
      case 3: {
        if (tag == 24) {
         parse_capability:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::Capability_IsValid(value)) {
            set_capability(static_cast< ::protocol::Capability >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.Chest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.Chest)
  return false;
#undef DO_
}

void Chest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.Chest)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 survive_timetravels = 2;
  if (has_survive_timetravels()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->survive_timetravels(), output);
  }

  // optional .protocol.Capability capability = 3;
  if (has_capability()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->capability(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.Chest)
}

::google::protobuf::uint8* Chest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.Chest)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required uint32 survive_timetravels = 2;
  if (has_survive_timetravels()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->survive_timetravels(), target);
  }

  // optional .protocol.Capability capability = 3;
  if (has_capability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->capability(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.Chest)
  return target;
}

int Chest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 survive_timetravels = 2;
    if (has_survive_timetravels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->survive_timetravels());
    }

    // optional .protocol.Capability capability = 3;
    if (has_capability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->capability());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Chest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Chest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Chest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Chest::MergeFrom(const Chest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_survive_timetravels()) {
      set_survive_timetravels(from.survive_timetravels());
    }
    if (from.has_capability()) {
      set_capability(from.capability());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Chest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Chest::CopyFrom(const Chest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Chest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Chest::Swap(Chest* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(survive_timetravels_, other->survive_timetravels_);
    std::swap(capability_, other->capability_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Chest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Chest_descriptor_;
  metadata.reflection = Chest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DeLorean::kIdFieldNumber;
const int DeLorean::kSurviveTimetravelsFieldNumber;
#endif  // !_MSC_VER

DeLorean::DeLorean()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.DeLorean)
}

void DeLorean::InitAsDefaultInstance() {
}

DeLorean::DeLorean(const DeLorean& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protocol.DeLorean)
}

void DeLorean::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  survive_timetravels_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeLorean::~DeLorean() {
  // @@protoc_insertion_point(destructor:protocol.DeLorean)
  SharedDtor();
}

void DeLorean::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DeLorean::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeLorean::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeLorean_descriptor_;
}

const DeLorean& DeLorean::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Elements_2eproto();
  return *default_instance_;
}

DeLorean* DeLorean::default_instance_ = NULL;

DeLorean* DeLorean::New() const {
  return new DeLorean;
}

void DeLorean::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DeLorean*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, survive_timetravels_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DeLorean::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.DeLorean)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_survive_timetravels;
        break;
      }

      // required uint32 survive_timetravels = 2;
      case 2: {
        if (tag == 16) {
         parse_survive_timetravels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &survive_timetravels_)));
          set_has_survive_timetravels();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.DeLorean)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.DeLorean)
  return false;
#undef DO_
}

void DeLorean::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.DeLorean)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 survive_timetravels = 2;
  if (has_survive_timetravels()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->survive_timetravels(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.DeLorean)
}

::google::protobuf::uint8* DeLorean::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.DeLorean)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required uint32 survive_timetravels = 2;
  if (has_survive_timetravels()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->survive_timetravels(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.DeLorean)
  return target;
}

int DeLorean::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 survive_timetravels = 2;
    if (has_survive_timetravels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->survive_timetravels());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeLorean::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DeLorean* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DeLorean*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeLorean::MergeFrom(const DeLorean& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_survive_timetravels()) {
      set_survive_timetravels(from.survive_timetravels());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DeLorean::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeLorean::CopyFrom(const DeLorean& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeLorean::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DeLorean::Swap(DeLorean* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(survive_timetravels_, other->survive_timetravels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DeLorean::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeLorean_descriptor_;
  metadata.reflection = DeLorean_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

// @@protoc_insertion_point(global_scope)
